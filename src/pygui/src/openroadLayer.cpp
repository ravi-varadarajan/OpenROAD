/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2020, OpenROAD
// All rights reserved.
//
// BSD 3-Clause License
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of the copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
///////////////////////////////////////////////////////////////////////////////

#include "pygui/openroadLayer.h"

#include <algorithm>
#include <iostream>
#include <sstream>
#include <string>

#include "pygui/openroadGlobals.h"

namespace OpenRoadUI {
GLPen* GLPen::_currentActivePen = nullptr;
GLubyte penPatterns[(unsigned int) OR_END_PAT][128]
    = {{// OR_FILL_NONE_PAT,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
       {// OR_FILL_SOLID_PAT
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
       {// OR_LEFT_DIAG_PAT
        0x88, 0x88, 0x88, 0x88, 0x44, 0x44, 0x44, 0x44, 0x22, 0x22, 0x22, 0x22,
        0x11, 0x11, 0x11, 0x11, 0x88, 0x88, 0x88, 0x88, 0x44, 0x44, 0x44, 0x44,
        0x22, 0x22, 0x22, 0x22, 0x11, 0x11, 0x11, 0x11, 0x88, 0x88, 0x88, 0x88,
        0x44, 0x44, 0x44, 0x44, 0x22, 0x22, 0x22, 0x22, 0x11, 0x11, 0x11, 0x11,
        0x88, 0x88, 0x88, 0x88, 0x44, 0x44, 0x44, 0x44, 0x22, 0x22, 0x22, 0x22,
        0x11, 0x11, 0x11, 0x11, 0x88, 0x88, 0x88, 0x88, 0x44, 0x44, 0x44, 0x44,
        0x22, 0x22, 0x22, 0x22, 0x11, 0x11, 0x11, 0x11, 0x88, 0x88, 0x88, 0x88,
        0x44, 0x44, 0x44, 0x44, 0x22, 0x22, 0x22, 0x22, 0x11, 0x11, 0x11, 0x11,
        0x88, 0x88, 0x88, 0x88, 0x44, 0x44, 0x44, 0x44, 0x22, 0x22, 0x22, 0x22,
        0x11, 0x11, 0x11, 0x11, 0x88, 0x88, 0x88, 0x88, 0x44, 0x44, 0x44, 0x44,
        0x22, 0x22, 0x22, 0x22, 0x11, 0x11, 0x11, 0x11},
       {// OR_LEFT_DIAG_SPARSE_PAT
        0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04,
        0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x80, 0x80, 0x80, 0x80,
        0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20, 0x10, 0x10, 0x10, 0x10,
        0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40,
        0x20, 0x20, 0x20, 0x20, 0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08,
        0x04, 0x04, 0x04, 0x04, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01,
        0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20,
        0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x04, 0x04, 0x04, 0x04,
        0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01},
       {// OR_RIGHT_DIAG_PAT
        0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22, 0x44, 0x44, 0x44, 0x44,
        0x88, 0x88, 0x88, 0x88, 0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22,
        0x44, 0x44, 0x44, 0x44, 0x88, 0x88, 0x88, 0x88, 0x11, 0x11, 0x11, 0x11,
        0x22, 0x22, 0x22, 0x22, 0x44, 0x44, 0x44, 0x44, 0x88, 0x88, 0x88, 0x88,
        0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22, 0x44, 0x44, 0x44, 0x44,
        0x88, 0x88, 0x88, 0x88, 0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22,
        0x44, 0x44, 0x44, 0x44, 0x88, 0x88, 0x88, 0x88, 0x11, 0x11, 0x11, 0x11,
        0x22, 0x22, 0x22, 0x22, 0x44, 0x44, 0x44, 0x44, 0x88, 0x88, 0x88, 0x88,
        0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22, 0x44, 0x44, 0x44, 0x44,
        0x88, 0x88, 0x88, 0x88, 0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22,
        0x44, 0x44, 0x44, 0x44, 0x88, 0x88, 0x88, 0x88},
       {// OR_RIGHT_DIAG_SPARSE_PAT
        0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04,
        0x08, 0x08, 0x08, 0x08, 0x10, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x20,
        0x40, 0x40, 0x40, 0x40, 0x80, 0x80, 0x80, 0x80, 0x01, 0x01, 0x01, 0x01,
        0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x08, 0x08, 0x08, 0x08,
        0x10, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x40, 0x40,
        0x80, 0x80, 0x80, 0x80, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,
        0x04, 0x04, 0x04, 0x04, 0x08, 0x08, 0x08, 0x08, 0x10, 0x10, 0x10, 0x10,
        0x20, 0x20, 0x20, 0x20, 0x40, 0x40, 0x40, 0x40, 0x80, 0x80, 0x80, 0x80,
        0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04,
        0x08, 0x08, 0x08, 0x08, 0x10, 0x10, 0x10, 0x10, 0x20, 0x20, 0x20, 0x20,
        0x40, 0x40, 0x40, 0x40, 0x80, 0x80, 0x80, 0x80},
       {// OR_HORIZONTAL_PAT
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
       {// OR_HORIZONTAL_SPARSE_PAT
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
       {// OR_VERTICAL_PAT
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
        0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55},
       {// OR_VERTICAL_SPARSE_PAT
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11},
       {// OR_CROSS_PAT
        0x81, 0x81, 0x81, 0x81, 0x42, 0x42, 0x42, 0x42, 0x24, 0x24, 0x24, 0x24,
        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x24, 0x24, 0x24, 0x24,
        0x42, 0x42, 0x42, 0x42, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
        0x42, 0x42, 0x42, 0x42, 0x24, 0x24, 0x24, 0x24, 0x18, 0x18, 0x18, 0x18,
        0x18, 0x18, 0x18, 0x18, 0x24, 0x24, 0x24, 0x24, 0x42, 0x42, 0x42, 0x42,
        0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x42, 0x42, 0x42, 0x42,
        0x24, 0x24, 0x24, 0x24, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
        0x24, 0x24, 0x24, 0x24, 0x42, 0x42, 0x42, 0x42, 0x81, 0x81, 0x81, 0x81,
        0x81, 0x81, 0x81, 0x81, 0x42, 0x42, 0x42, 0x42, 0x24, 0x24, 0x24, 0x24,
        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x24, 0x24, 0x24, 0x24,
        0x42, 0x42, 0x42, 0x42, 0x81, 0x81, 0x81, 0x81},
       {// OR_CHECK_PAT
        0xff, 0xff, 0xff, 0xff, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x99, 0x99, 0x99, 0x99,
        0x99, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x99, 0x99, 0x99, 0x99,
        0x99, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x99, 0x99, 0x99, 0x99,
        0x99, 0x99, 0x99, 0x99, 0xff, 0xff, 0xff, 0xff},
       {// OR_BLOCK_PAT
        0x1f, 0x3e, 0x7c, 0xf8, 0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88,
        0x11, 0x22, 0x44, 0x88, 0x1f, 0x3e, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x1f, 0x3e, 0x7c, 0xf8, 0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88,
        0x11, 0x22, 0x44, 0x88, 0x1f, 0x3e, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x1f, 0x3e, 0x7c, 0xf8, 0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88,
        0x11, 0x22, 0x44, 0x88, 0x1f, 0x3e, 0x7c, 0xf8, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x1f, 0x3e, 0x7c, 0xf8, 0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88,
        0x11, 0x22, 0x44, 0x88, 0x1f, 0x3e, 0x7c, 0xf8}};

NamedColorMap_t GLPen::_namedColors
    = {{"red", ColorParams(1.0f, 0.0f, 0.0f)},
       {"white", ColorParams(1.0f, 1.0f, 1.0f)},
       {"yellow", ColorParams(1.0f, 1.0f, 0.0f)},
       {"purple", ColorParams(1.0f, 0.0f, 1.0f)},
       {"light blue", ColorParams(0.0f, 1.0f, 1.0f)},
       {"brown", ColorParams(1.0f, 0.5f, 0.0f)},
       {"green", ColorParams(0.0f, 1.0f, 0.0f)},
       {"blue", ColorParams(0.0f, 0.0f, 1.0f)},
       {"cyan", ColorParams(0.5f, 1.0f, 1.0f)},
       {"black", ColorParams(0.0f, 0.0f, 0.0f)},
       {"orange", ColorParams(1.0f, 0.5f, 0.0f)},
       {"blue-green", ColorParams(0.0f, 0.5f, 0.5f)},
       {"baby blue", ColorParams(0.0f, 0.5f, 1.0f)},
       {"lilac", ColorParams(1.0f, 0.5f, 1.0f)},
       {"dark grey", ColorParams(0.1f, 0.1f, 0.1f)},
       {"dark purple", ColorParams(0.1f, 0.0f, 0.1f)},
       {"bronze", ColorParams(0.1f, 0.1f, 0.0f)},
       {"dark blue", ColorParams(0.0f, 0.1f, 0.1f)},
       {"forest green", ColorParams(0.0f, 0.1f, 0.0f)}};
NamedPenMap_t GLPen::_namedPens
    = {{"red", GLPen(ColorParams(1.0f, 0.0f, 0.0f))},
       {"white", GLPen(ColorParams(1.0f, 1.0f, 1.0f))},
       {"yellow", GLPen(ColorParams(1.0f, 1.0f, 0.0f))},
       {"purple", GLPen(ColorParams(1.0f, 0.0f, 1.0f))},
       {"light blue", GLPen(ColorParams(0.0f, 1.0f, 1.0f))},
       {"brown", GLPen(ColorParams(1.0f, 0.5f, 0.0f))},
       {"green", GLPen(ColorParams(0.0f, 1.0f, 0.0f))},
       {"blue", GLPen(ColorParams(0.0f, 0.0f, 1.0f))},
       {"cyan", GLPen(ColorParams(0.5f, 1.0f, 1.0f))},
       {"black", GLPen(ColorParams(0.0f, 0.0f, 0.0f))},
       {"purple", GLPen(ColorParams(1.0f, 0.0f, 1.0f))},
       {"orange", GLPen(ColorParams(1.0f, 0.5f, 0.0f))},
       {"blue-green", GLPen(ColorParams(0.0f, 0.5f, 0.5f))},
       {"baby blue", GLPen(ColorParams(0.0f, 0.5f, 1.0f))},
       {"lilac", GLPen(ColorParams(1.0f, 0.5f, 1.0f))},
       {"dark grey", GLPen(ColorParams(0.1f, 0.1f, 0.1f))},
       {"dark purple", GLPen(ColorParams(0.1f, 0.0f, 0.1f))},
       {"bronze", GLPen(ColorParams(0.1f, 0.1f, 0.0f))},
       {"dark blue", GLPen(ColorParams(0.0f, 0.1f, 0.1f))},
       {"forest green", GLPen(ColorParams(0.0f, 0.1f, 0.0f))}};

GLLayer* GLLayer::_rootLayer = nullptr;
std::unordered_map<int, GLLayer*> GLLayer::_allLayers
    = std::unordered_map<int, GLLayer*>();

/*
    ColorParams::ColorParams(const ColorParams& cParam) : red_(cParam.red_),
   green_(cParam.green_), blue_(cParam.blue_) {} ColorParams&
    ColorParams::operator=(const ColorParams& cParam)
    {
        if (this == &cParam)
            return *this ;
        red_ = cParam.red_ ;
        green_ = cParam.green_ ;
        blue_ = cParam.blue_ ;
        alpha_ = cParam.alpha_ ;
        return *this ;
    }
*/
float ColorParams::red() const
{
  return red_;
}

float ColorParams::green() const
{
  return green_;
}

float ColorParams::blue() const
{
  return blue_;
}

float ColorParams::alpha() const
{
  return alpha_;
}

GLPen::GLPen() : penPattern_(OR_FILL_NONE_PAT), colorName_("black")
{
  penValid_ = false;
  if (getParamsForColor(colorName_, penColorParams_))
    penValid_ = true;
}

GLPen::GLPen(const ColorParams& colorVal, ORPenPatternType pat)
    : penColorParams_(colorVal),
      penPattern_(pat),
      colorName_(""),
      penValid_(true)
{
}

GLPen::GLPen(const std::string& colorName, ORPenPatternType pat)
    : penPattern_(pat), colorName_(colorName)
{
  penValid_ = false;
  if (getParamsForColor(colorName, penColorParams_))
    penValid_ = true;
}

GLPen::~GLPen()
{
  // TBD
}

ColorParams GLPen::getPenColorVals() const
{
  return penColorParams_;
}

void GLPen::setPenColorVals(ColorParams params)
{
  penColorParams_ = params;
}

ORPenPatternType GLPen::getPenPattern() const
{
  return penPattern_;
}

void GLPen::setPenPattern(ORPenPatternType pat)
{
  penPattern_ = pat;
}

bool GLPen::isNamedColor() const
{
  return colorName_.empty() == false;
}

bool GLPen::setColor(const std::string& colorName)
{
  colorName_ = colorName;
  penValid_ = false;
  if (getParamsForColor(colorName_, penColorParams_))
    penValid_ = true;
  return penValid_;
}

bool GLPen::isPenValid() const
{
  return penValid_;
}

bool GLPen::setGLPenContext()
{
  std::stringstream oss;
  if (!penValid_) {
    oss << "\t Pen is invalid bailing out, valid flag " << penValid_ << ", "
        << penPattern_ << " Color = " << colorName_ << std::endl;
    DEBUG_PRINT_ALL(oss.str());
    oss.clear();
    return false;
  }

  GLfloat redV = static_cast<GLfloat>(penColorParams_.red());
  GLfloat greenV = static_cast<GLfloat>(penColorParams_.green());
  GLfloat blueV = static_cast<GLfloat>(penColorParams_.blue());
  GLfloat alphaV = static_cast<GLfloat>(penColorParams_.alpha());

  oss << "\n Setting RGBA as " << redV << "," << greenV << "," << blueV << ","
      << alphaV;
  DEBUG_PRINT(oss.str());

  glColor4f(redV, greenV, blueV, alphaV);
  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
  glEnable(GL_POLYGON_STIPPLE);
  GLubyte* pattern = GLPen::getPenBytePattern(penPattern_);
  glPolygonStipple(pattern);

  _currentActivePen = this;

  return true;
}

// static Function
bool GLPen::getParamsForColor(const std::string& colorName,
                              ColorParams& cParams)
{
  std::string inpColor = colorName;
  std::transform(
      colorName.begin(), colorName.end(), inpColor.begin(), ::tolower);
  auto itr = _namedColors.find(inpColor);
  if (itr != _namedColors.end()) {
    cParams = (*itr).second;
    return true;
  }
  std::cout << "Failed to get params for the color = " << colorName
            << std::endl;
  return false;
}

GLPen GLPen::getPen(std::string penColor)
{
  if (_namedPens.find(penColor) == _namedPens.end())
    penColor = "red";
  return _namedPens[penColor];
}

// static
GLubyte* GLPen::getPenBytePattern(unsigned int patIdx)
{
  return penPatterns[patIdx];
}

GLLayer::GLLayer(const std::string& layerName,
                 int layerIdx,
                 ORLayerType layerType,
                 bool internalLayer)
    : layerName_(layerName),
      layerIdx_(layerIdx),
      layerType_(layerType),
      selectable_(true),
      visible_(true),
      internalLayer_(internalLayer),
      layerUserData_(nullptr),
      layerPen_(nullptr),
      parent_(nullptr)
{
  // Create a dummy pen, it will be deleted as soon as any pen is set for the
  // layer
  layerPen_ = new GLPen("purple", OR_FILL_NONE_PAT);
  _allLayers[layerIdx_] = this;
}

GLLayer::~GLLayer()
{
  // return ;
  if (layerPen_ != nullptr)
    delete layerPen_;
  std::for_each(childLayers_.begin(), childLayers_.end(), [](GLLayer* layer) {
    delete layer;
  });
  childLayers_.clear();
  parent_ = nullptr;
  _allLayers.erase(layerIdx_);
}

void GLLayer::addChildLayer(GLLayer* layer)
{
  childLayers_.push_back(layer);
}

std::string GLLayer::getLayerName() const
{
  return layerName_;
}

ORLayerType GLLayer::getLayerType() const
{
  return layerType_;
}

int GLLayer::getLayerIdx() const
{
  return layerIdx_;
}

int GLLayer::getChildCount(bool includeInternalLayer) const
{
  if (includeInternalLayer == true)
    return childLayers_.size();
  return std::count_if(
      childLayers_.begin(), childLayers_.end(), [](auto& p_layer) {
        return p_layer->isInternalLayer() == false;
      });
}

GLLayer* GLLayer::getChildLayerAt(uint idx) const
{
  if (idx >= childLayers_.size())
    return nullptr;
  return childLayers_[idx];
}

void GLLayer::getChildLayerIdsRecurse(std::vector<uint>& layerIds,
                                      bool checkSelectability,
                                      bool checkVisibility,
                                      bool includeInternalLayer) const
{
  bool includeLayer = true;
  if (checkVisibility && !visible_)
    includeLayer = false;
  if (includeLayer && (checkSelectability && !selectable_))
    includeLayer = false;
  if (includeLayer) {
    if (includeInternalLayer || internalLayer_ == false)
      layerIds.push_back(layerIdx_);
  }
  for (auto childLayer : childLayers_)
    childLayer->getChildLayerIdsRecurse(
        layerIds, checkSelectability, checkVisibility, includeInternalLayer);
  return;
}

void GLLayer::setLayerVisible(bool val)
{
  visible_ = val;
  for (auto& child : childLayers_)
    child->setLayerVisible(val);
}

void GLLayer::setLayerSelectable(bool val)
{
  selectable_ = val;
  for (auto& child : childLayers_)
    child->setLayerSelectable(val);
}

void GLLayer::setLayerPen(GLPen* pen)
{
  if (layerPen_)
    delete layerPen_;
  layerPen_ = pen;
}

void GLLayer::dumpLayers(GLLayer* layer, int level)
{
  if (layer == nullptr)
    layer = _rootLayer;

  for (int c = 0; c < level; c++)
    std::cout << "  ";

  std::cout << layer->layerName_ << " " << layer->layerIdx_ << " "
            << layer->layerType_ << " " << layer->visible_ << " "
            << layer->selectable_ << " " << std::endl;

  std::vector<GLLayer*>::iterator litr;
  for (litr = layer->childLayers_.begin(); litr != layer->childLayers_.end();
       litr++) {
    dumpLayers(*litr, level + 1);
  }
}

std::vector<uint> GLLayer::getWorldViewDrawLayers() const
{
  std::vector<uint> layers;
  if (getLayerType() == DUMMY_LAYER_0) {
    for (auto& p_layer : childLayers_)
      layers.push_back(p_layer->getLayerIdx());
  } else if (getLayerName() == "ROOT") {  // Design Layers
    GLLayer* p_designLayer = nullptr;
    std::vector<uint> allLayerIds;
    std::vector<ORLayerType> layersToChoose { DESIGN_INSTANCE_LAYER,
                                              DESIGN_CELLTYPE_LAYER,
                                              DESIGN_STD_CELL_LAYER,
                                              DESIGN_BLACKBOX_LAYER,
                                              //DESIGN_COVERCELL_LAYER,
                                              //DESIGN_PHYSICAL_CELL_LAYER,
                                              //DESIGN_FILLER_CELL_LAYER,
                                              DESIGN_MACRO_LAYER,
                                              DESIGN_IO_CELL_LAYER,
                                              DESIGN_IO_LAYER} ;
    getChildLayerIdsRecurse(allLayerIds, false, false, false);
    for (auto layerIdx : allLayerIds) {
      GLLayer* p_layer = GLLayer::getLayerAt(layerIdx);
      if(std::find(layersToChoose.begin(), layersToChoose.end(), layerIdx) != layersToChoose.end())
        layers.push_back(layerIdx);
    }
  }
  return layers;
}

std::vector<uint> GLLayer::getWorldViewSelectLayers() const
{
  std::vector<uint> layers;
  std::vector<uint> allLayerIds;
  getChildLayerIdsRecurse(allLayerIds, false, false, true);
  for (auto layerIdx : allLayerIds) {
    GLLayer* p_layer = GLLayer::getLayerAt(layerIdx);
    if (p_layer->getLayerType() == WORLD_VIEW_LAYER)
      layers.push_back(layerIdx);
  }
  return layers;
}

// static
GLLayer* GLLayer::getLayerAt(uint idx)
{
  return _allLayers[idx];
}

// static
uint GLLayer::allLayerCount()
{
  return _allLayers.size();
}

// static
uint GLLayer::leafLayersCount()
{
  uint leafCount = 0;
  for (auto& layerItem : _allLayers) {
    GLLayer* layer = layerItem.second;
    if (layer->getChildCount() != 0)
      leafCount++;
  }
  return leafCount;
}

// static
void GLLayer::setRootLayer(GLLayer* root)
{
  _rootLayer = root;
}

// static
GLLayer* GLLayer::getRootLayer()
{
  return _rootLayer;
}

GLLayer* GLLayer::createDummyLayerTree(bool outlineOnly)
{
  // Create a Dummy Top Layer
  int layerIdx = 0;
  std::string topLayerName("DummyTop");
  ORLayerType curLayerType = DUMMY_LAYER_0;
  GLLayer* topLayer
      = new GLLayer(topLayerName, layerIdx, curLayerType, outlineOnly);
  std::vector<std::string> penColors{
      "red", "yellow", "green", "lilac", "purple", "cyan", "black"};
  // std::vector<ORPenPatternType> penPats { OR_FILL_SOLID_PAT,
  // OR_LEFT_DIAG_PAT, OR_LEFT_DIAG_SPARSE_PAT, OR_CROSS_PAT, OR_VERTICAL_PAT,
  // OR_FILL_NONE_PAT} ;
  std::vector<ORPenPatternType> penPats{OR_FILL_SOLID_PAT,
                                        OR_LEFT_DIAG_PAT,
                                        OR_LEFT_DIAG_SPARSE_PAT,
                                        OR_FILL_NONE_PAT,
                                        OR_VERTICAL_PAT,
                                        OR_FILL_NONE_PAT,
                                        OR_FILL_NONE_PAT};
  for (layerIdx = 1; layerIdx <= 7; ++layerIdx) {
    std::string layerName("ChildLayer ");
    layerName += std::to_string(layerIdx);
    GLLayer* layer
        = new GLLayer(layerName,
                      layerIdx,
                      static_cast<ORLayerType>(curLayerType + layerIdx),
                      outlineOnly);
    topLayer->addChildLayer(layer);
    GLPen* pen = new GLPen(penColors[layerIdx - 1], penPats[layerIdx - 1]);
    // OpenRoadPen* pen = new OpenRoadPen(penColors[layerIdx-1],
    // OR_FILL_NONE_PAT) ;
    layer->setLayerPen(pen);
    if (layerIdx == 6)
      layer->setLayerSelectable(false);
    if (outlineOnly) {
      layer->setLayerVisible(false);
      layer->setLayerSelectable(false);
    }
  }

  std::string wvLayerName("WorldViewerLayer");
  GLLayer* layer = new GLLayer(wvLayerName, layerIdx, WORLD_VIEW_LAYER, true);
  layer->setLayerVisible(false);
  layer->setLayerSelectable(false);
  topLayer->addChildLayer(layer);
  GLPen* pen = new GLPen("yellow", OR_LEFT_DIAG_SPARSE_PAT);
  layer->setLayerPen(pen);
  std::stringstream oss;
  oss << "Created Dummy Layer Tree with " << topLayer->getChildCount()
      << " Leaf Layers under top";
  DEBUG_PRINT(oss.str());
  return topLayer;
}
}  // namespace OpenRoadUI
